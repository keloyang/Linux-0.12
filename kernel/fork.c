/*
 *  linux/kernel/fork.c
 *
 *  (C) 1991  Linus Torvalds
 */

/*
 *  'fork.c' contains the help-routines for the 'fork' system call
 * (see also system_call.s), and some misc functions ('verify_area').
 * Fork is rather simple, once you get the hang of it, but the memory
 * management can be a bitch. See 'mm/mm.c': 'copy_page_tables()'
 */
/*
 * 'fork.c'?Do?¨®D?¦Ì¨ª3¦Ì¡Â¨®?'fork'¦Ì??¡§?¨²¡Á¨®3¨¬D¨°,¨°??¡ã¨°?D?????o¡¥¨ºy('verify_area').¨°?¦Ì???¨¢??a¨¢?fork,?¨ª?¨¢¡¤¡é???¨¹¡¤?3¡ê?¨°¦Ì£¤¦Ì?,¦Ì?
 * ?¨²¡ä?1¨¹¨¤¨ª¨¨¡ä¨®DD????¨¨.2???'mm/memory.c'?D¦Ì?'copy_page_tables()'o¡¥¨ºy.
 */
#include <errno.h>							// ¡ä¨ª?¨®o?¨ª¡¤???t.¡ã¨¹o??¦Ì¨ª3?D?¡Â??3?¡ä¨ªo?.

#include <linux/sched.h>					// ¦Ì¡Â¨º?3¨¬D¨°¨ª¡¤???t,?¡§¨°?¨¢?¨¨????¨¢11task_struct,¨¨???0¦Ì?¨ºy?Y.
#include <linux/kernel.h>
//#include <asm/segment.h>
#include <asm/system.h>

// D¡ä¨°3???¨¦?¡è.¨¨?¨°3??2??¨¦D¡ä,?¨°?¡ä??¨°3??.?¡§¨°??¨²mm/memory.c.
extern void write_verify(unsigned long address);

long last_pid = 0;							// ¡Á?D???3¨¬o?,???¦Ì?¨¢¨®¨¦get_empty_process()¨¦¨²3¨¦.

// ??3¨¬??????¨®¨°D¡ä?¡ã?¨¦?¡èo¡¥¨ºy.
// ??¨®¨²80386 CPU,?¨²?¡äDD¨¬?¨¨¡§??0¡ä¨²??¨º¡À2??¨¢¨¤¨ª?¨¢¨®??¡ì?????D¦Ì?¨°3??¨º?¡¤?¨º?¨°3¡À¡ê?¡è¦Ì?,¨°¨°¡ä??¨²?¡äDD?¨²o?¡ä¨²??¨º¡À¨®??¡ì?????D¨ºy?Y¨°3??¡À¡ê?¡è¡À¨º???e2?
// ¨¢?¡Á¡Â¨®?,D¡ä¨º¡À?¡ä???¨²??¨°2?¨ª¨º¡ì¨¨£¤¨¢?¡Á¡Â¨®?.verify_area()o¡¥¨ºy?¨ª¨®?¨®¨²¡ä???¦Ì?.¦Ì???¨®¨²80486?¨°o¨®¨¤¡ä¦Ì?CPU,????????¡ä??¡ÂCR0?D¨®D¨°???D¡ä¡À¡ê?¡è¡À¨º
// ??WP(??16),?¨²o??¨¦¨°?¨ª¡§1y¨¦¨¨????¡À¨º??¨¤¡ä???1¨¬?¨¨¡§??0¦Ì?¡ä¨²???¨°¨®??¡ì???????¨¢¨°3???¡äDDD¡ä¨ºy?Y,¡¤??¨°??¦Ì???¡¤¡é¨¦¨²D¡ä¡À¡ê?¡è¨°¨¬3¡ê.¡ä¨®??486¨°?¨¦?CPU
// ?¨¦¨°?¨ª¡§1y¨¦¨¨????¡À¨º??¨¤¡ä¡ä?¦Ì?¨º1¨®?¡À?o¡¥¨ºy¨ª??¨´¦Ì???¦Ì?.??o¡¥¨ºy??¦Ì¡À?¡ã??3¨¬???-¦Ì??¡¤¡ä¨®addr¦Ì?addr + size?a¨°???¡¤??¡ì¨°?¨°3?a¦Ì£¤???¡äDDD¡ä2¨´¡Á¡Â?¡ã
// ¦Ì??¨¬2a2¨´¡Á¡Â.¨®¨¦¨®¨²?¨¬2a?D??¨º?¨°?¨°3???a¦Ì£¤????DD2¨´¡Á¡Â,¨°¨°¡ä?3¨¬D¨°¨º¡Á?¨¨D¨¨¨°a?¨°3?addr?¨´?¨²¨°3???a¨º?¦Ì??¡¤start,¨¨?o¨®start?¨®¨¦???3¨¬¨ºy?Y???¨´?¡¤,
// ¨º1?a??start¡À???3¨¦CPU 4GB??D??????D¦Ì?¦Ì??¡¤.¡Á?o¨®?-?¡¤¦Ì¡Â¨®?write_verify()?????¡§¡ä¨®D?¦Ì??¨²¡ä???????DDD¡ä?¡ã?¨¦?¡è.¨¨?¨°3??¨º????¨¢¦Ì?,
// ?¨°?¡äDD12?¨ª?¨¬?¨¦o¨ª?¡ä??¨°3??2¨´¡Á¡Â(D¡ä¨º¡À?¡ä??).
void verify_area(void * addr, int size)
{
	unsigned long start;

	// ¨º¡Á?¨¨???e¨º?¦Ì??¡¤start¦Ì¡Â???a???¨´?¨²¨°3¦Ì?¡Á¨®¡À????a¨º?????,¨ª?¨º¡À?¨¤¨®|¦Ì?¦Ì¡Â???¨¦?¡è??¨®¨°¡ä¨®D?.?????D¦Ì?start & 0xfff¨®?¨¤¡ä??¦Ì????¡§?e¨º?????addr
	// (¨°2?¡ästart)?¨²?¨´?¨²¨°3???D¦Ì???¨°??¦Ì,?-?¨¦?¡è¡¤??¡ìsize?¨®¨¦??a????¨°??¦Ì?¡ä¨¤??13¨¦¨°?addr?¨´?¨²¨°3???e¨º??????a¨º?¦Ì?¡¤??¡ì?¦Ì.¨°¨°¡ä??¨²30DD¨¦?¨°2D¨¨¨°a
	// ¡ã??¨¦?¡è?a¨º?????start¦Ì¡Â??3¨¦¨°3??¡À????¦Ì.
	start = (unsigned long) addr;
	size += start & 0xfff;
	start &= 0xfffff000;					// ¡ä?¨º¡Àstart¨º?¦Ì¡À?¡ã??3¨¬?????D¦Ì????-¦Ì??¡¤.
	// ????¡ã?start?¨®¨¦???3¨¬¨ºy?Y???¨²??D?¦Ì??¡¤?????D¦Ì??e¨º??¨´?¡¤,¡À?3¨¦?¦Ì¨ª3??????D??????D¦Ì?¦Ì??¡¤????.??¨®¨²Linux0.1x?¨²o?,??¨ºy?Y??o¨ª¡ä¨²?????¨²
	// ??D?¦Ì??¡¤?????D¦Ì??¨´?¡¤o¨ª?T3¡è?¨´?¨¤¨ª?.¨¨?o¨®?-?¡¤??DDD¡ä¨°3???¨¦?¡è.¨¨?¨°3??2??¨¦D¡ä,?¨°?¡ä??¨°3??.(mm/memory.c)
	start += get_base(current->ldt[2]);
	while (size > 0) {
		size -= 4096;
		write_verify(start);				// include/linux/sched.h
		start += 4096;
	}
}

// ?¡ä???¨²¡ä?¨°3¡À¨ª.
// 2?¨ºynr¨º?D?¨¨???o?;p¨º?D?¨¨???¨ºy?Y?¨¢11????.??o¡¥¨ºy?aD?¨¨????¨²??D?¦Ì??¡¤?????D¨¦¨¨??¡ä¨²????o¨ª¨ºy?Y???¨´?¡¤,?T3¡è,2¡é?¡ä??¨°3¡À¨ª.¨®¨¦¨®¨²Linux?¦Ì¨ª32¨¦¨®?D¡ä¨º¡À
// ?¡ä??(copy on write)??¨º?,¨°¨°¡ä??a¨¤????aD???3¨¬¨¦¨¨??¡Á??o¦Ì?¨°3????¡À¨ª??o¨ª¨°3¡À¨ª??,????¨®D¨º¦Ì?¨º?aD???3¨¬¡¤?????¨¤¨ª?¨²¡ä?¨°3??.¡ä?¨º¡ÀD???3¨¬¨®???????3¨¬
// 12?¨ª?¨´¨®D?¨²¡ä?¨°3??.2¨´¡Á¡Â3¨¦1|¡¤¦Ì??0,¡¤??¨°¡¤¦Ì??3?¡ä¨ªo?.
int copy_mem(int nr, struct task_struct * p)
{
	unsigned long old_data_base, new_data_base, data_limit;
	unsigned long old_code_base, new_code_base, code_limit;

	// ¨º¡Á?¨¨¨¨?¦Ì¡À?¡ã??3¨¬??2??¨¨¨º?¡¤?¡À¨ª?D¡ä¨²?????¨¨¨º?¡¤?o¨ª¨ºy?Y???¨¨¨º?¡¤????D¦Ì????T3¡è(¡Á??¨²¨ºy).
	// 0x0f¨º?¡ä¨²????????¡¤?;0x17¨º?¨ºy?Y??????¡¤?.¨¨?o¨®¨¨?¦Ì¡À?¡ã??3¨¬¡ä¨²????o¨ª¨ºy?Y??¦Ì???D?¦Ì??¡¤?????D¦Ì??¨´¦Ì??¡¤.¨®¨¦¨®¨²Linux0.12?¨²o??12??¡ì3?¡ä¨²??o¨ª¨ºy?Y??¡¤?¨¢¡é¦Ì??¨¦??,
	// ¨°¨°¡ä??a¨¤?D¨¨¨°a?¨¬2¨¦¡ä¨²????o¨ª¨ºy?Y???¨´?¡¤¨º?¡¤????¨¤¨ª?,2¡é?¨°¨°a?¨®¨ºy?Y??¦Ì?3¡è?¨¨?¨¢¨¦¨´2?D?¨®¨²¡ä¨²????¦Ì?3¡è?¨¨,¡¤??¨°?¨²o???¨º?3?¡ä¨ªD??¡é,2¡é¨ª¡ê?1??DD.
	// get_limit()o¨ªget_base()?¡§¨°??¨²include/linux/sched.h.
	code_limit = get_limit(0x0f);
	data_limit = get_limit(0x17);
	old_code_base = get_base(current->ldt[1]);
	old_data_base = get_base(current->ldt[2]);
	if (old_data_base != old_code_base)
		panic("We don't support separate I&D");
	if (data_limit < code_limit)
		panic("Bad data_limit");
	// ¨¨?o¨®¨¦¨¨??¡ä¡ä?¡§?D¦Ì?D???3¨¬?¨²??D?¦Ì??¡¤?????D¦Ì??¨´¦Ì??¡¤¦Ì¨¨¨®¨²(64MB*??¨¨???o?),2¡é¨®????¦Ì¨¦¨¨??D???3¨¬??2??¨¨¨º?¡¤?¡À¨ª?D???¨¨¨º?¡¤??D¦Ì??¨´¦Ì??¡¤.?¨®¡Á?¨¦¨¨??D???3¨¬¦Ì?¨°3????
	// ¡À¨ª??o¨ª¨°3¡À¨ª??,?¡ä?¡ä??¦Ì¡À?¡ã??3¨¬(????3¨¬)¦Ì?¨°3????¡À¨ª??o¨ª¨°3¡À¨ª??.¡ä?¨º¡À¡Á¨®??3¨¬12?¨ª????3¨¬¦Ì??¨²¡ä?¨°3??.
	// ?y3¡ê?¨¦????copy_page_tables()¡¤¦Ì??0,¡¤??¨°¡À¨ª¨º?3?¡ä¨ª,?¨°¨º¨ª¡¤???¨¦¨º??¦Ì?¨°3¡À¨ª??.
	new_data_base = new_code_base = nr * TASK_SIZE;
	p->start_code = new_code_base;
	set_base(p->ldt[1], new_code_base);
	set_base(p->ldt[2], new_data_base);
	if (copy_page_tables(old_data_base, new_data_base, data_limit)) {
		free_page_tables(new_data_base, data_limit);
		return -ENOMEM;
	}
	return 0;
}

/*
 *  Ok, this is the main fork-routine. It copies the system process
 * information (task[nr]) and sets up the necessary registers. It
 * also copies the data segment in it's entirety.
 */
/*
 * OK,????¨º??¡Â¨°a¦Ì?fork¡Á¨®3¨¬D¨°.?¨¹?¡ä???¦Ì¨ª3??3¨¬D??¡é(task[n]),2¡é?¨°¨¦¨¨??¡À?¨°a¦Ì???¡ä??¡Â.?¨¹?1????¦Ì??¡ä??¨ºy?Y??(¨°2¨º?¡ä¨²????).
 */
// ?¡ä????3¨¬.
// ??o¡¥¨ºy¦Ì?2?¨ºy¨º???¨¨??¦Ì¨ª3¦Ì¡Â¨®??D??¡ä|¨¤¨ª1y3¨¬(sys_call.s)?a¨º?,?¡À¦Ì?¦Ì¡Â¨®?¡À??¦Ì¨ª3¦Ì¡Â¨®?¡ä|¨¤¨ª1y3¨¬o¨ª¦Ì¡Â¨®?¡À?o¡¥¨ºy?¡ã?e2??1¨¨???3¨¬?¨²o?¨¬???¦Ì??¡Â??¡ä??¡Â¦Ì??¦Ì.
// ?aD??¨²sys_call.s3¨¬D¨°?D?e2??1¨¨??¨²o???¦Ì??¦Ì(2?¨ºy)¡ã¨¹¨¤¡§:
// 1,CPU?¡äDD?D????¨¢??1¨¨?¦Ì?¨®??¡ì??¦Ì??¡¤sso¨ªesp,¡À¨º??eflagso¨ª¡¤¦Ì??¦Ì??¡¤cso¨ªeip;
// 2,?¨²????¨¨?system_call¨º¡À¨¨???¦Ì?????¡ä??¡Âds,es,fso¨ªedx,ecx,ebx;
// 3,¦Ì¡Â¨®?sys_call_table?Dsys_forko¡¥¨ºy¨¨???¦Ì?¡¤¦Ì??¦Ì??¡¤(2?¨ºynone¡À¨ª¨º?);
// 4,¦Ì¡Â¨®?copy_process()???¡ã¨¨???¦Ì?gs,esi,edi,ebpo¨ªeax(nr).
// ???D2?¨ºynr¨º?¦Ì¡Â¨®?find_empty_process()¡¤???¦Ì?¨¨???¨ºy¡Á¨¦??o?.
int copy_process(int nr, long ebp, long edi, long esi, long gs, long none,
		long ebx, long ecx, long edx, long orig_eax,
		long fs, long es, long ds,
		long eip, long cs, long eflags, long esp, long ss)
{
	struct task_struct *p;
	int i;
	struct file *f;

	// ¨º¡Á?¨¨?aD?¨¨???¨ºy?Y?¨¢11¡¤????¨²¡ä?.¨¨?1??¨²¡ä?¡¤???3?¡ä¨ª,?¨°¡¤¦Ì??3?¡ä¨ª??2¡é¨ª?3?.¨¨?o¨®??D?¨¨????¨¢11????¡¤?¨¨?¨¨???¨ºy¡Á¨¦¦Ì?nr???D.???Dnr?a¨¨???o?,¨®¨¦?¡ã??
	// find_empty_process()¡¤¦Ì??.?¨®¡Á?¡ã?¦Ì¡À?¡ã??3¨¬¨¨????¨¢11?¡ä??¦Ì???¨¦¨º??¦Ì?¦Ì??¨²¡ä?¨°3??p?a¨º?¡ä|.
	p = (struct task_struct *) get_free_page();
	if (!p)
		return -EAGAIN;
	task[nr] = p;
	*p = *current;							/* NOTE! this doesn't copy the supervisor stack */	/* ¡Á¡é¨°a!?a?¨´2??¨¢?¡ä??3???¨®??¡ì????(???¡ä????3¨¬?¨¢11) */
	//	memcpy(p, current, sizeof(struct task_struct));
	// ??o¨®???¡ä??¨¤¡ä¦Ì???3¨¬?¨¢11?¨²¨¨Y??DD¨°?D?DT??,¡Á¡Â?aD???3¨¬¦Ì?¨¨????¨¢11.?¨¨??D???3¨¬¦Ì?¡Á¡ä¨¬????a2??¨¦?D??¦Ì¨¨¡äy¡Á¡ä¨¬?,¨°?¡¤¨¤?1?¨²o?¦Ì¡Â¨º????¡äDD.¨¨?o¨®¨¦¨¨??D???3¨¬
	// ¦Ì???3¨¬o?pid,2¡é3?¨º??¡¥??3¨¬??DD¨º¡À?????¦Ì¦Ì¨¨¨®¨²??priorty?¦Ì(¨°?¡ã??a16??¨¤?¨¤a).?¨®¡Á??¡ä??D???3¨¬¦Ì?D?o???¨ª?,¡À¡§?¡¥?¡§¨º¡À?¦Ì,?¨¢?¡ã(session)¨¢¨¬¦Ì?¡À¨º??
	// leader,??3¨¬?¡ã??¡Á¨®??3¨¬?¨²?¨²o?o¨ª¨®??¡ì¨¬???DD¨º¡À??¨ª3???¦Ì,?1¨¦¨¨????3¨¬?a¨º???DD¦Ì??¦Ì¨ª3¨º¡À??start_time.
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;						// D???3¨¬o?.¨°2¨®¨¦find_empty_process()¦Ì?¦Ì?.
	p->counter = p->priority;				// ??DD¨º¡À?????¦Ì(¨¤?¨¤a¨ºy).
	p->signal = 0;							// D?o???¨ª?.
	p->alarm = 0;							// ¡À¡§?¡¥?¡§¨º¡À?¦Ì(¨¤?¨¤a¨ºy).
	p->leader = 0;							/* process leadership doesn't inherit */	/* ??3¨¬¦Ì?¨¢¨¬¦Ì?¨¨¡§¨º?2??¨¹?¨¬3D¦Ì? */
	p->utime = p->stime = 0;				// ¨®??¡ì¨¬?¨º¡À??o¨ªo?D?¨¬???DD¨º¡À??.
	p->cutime = p->cstime = 0;				// ¡Á¨®??3¨¬¨®??¡ì¨¬?o¨ªo?D?¨¬???DD¨º¡À??.
	p->start_time = jiffies;				// ??3¨¬?a¨º???DD¨º¡À??(¦Ì¡À?¡ã¨º¡À??¦Ì?¡äe¨ºy).
	// ?¨´DT??¨¨???¡Á¡ä¨¬???TSS¨ºy?Y.¨®¨¦¨®¨²?¦Ì¨ª3??¨¨????¨¢11p¡¤???¨¢?1¨°3D??¨²¡ä?,?¨´¨°?(PAGE_SIZE + (long) p)¨¨?esp0?yo????¨°??¨°3?£¤??.ss0:esp0¨®?¡Á¡Â3¨¬D¨°?¨²?¨²o?
	// ¨¬??¡äDD¨º¡À¦Ì???.¨¢¨ª¨ªa,?¨²¦Ì¨²3???D?¨°??¨°??-?a¦Ì¨¤,????¨¨????¨²GDT¡À¨ª?D??¨®D¨¢??????¨¨¨º?¡¤?,¨°???¨º?¨¨???¦Ì?TSS???¨¨¨º?¡¤?,¨¢¨ª¨°???¨º?¨¨???¦Ì?LDT¡À¨ª???¨¨¨º?¡¤?.????¨®????¨ª¨º?
	// ¡ã?GDT?D¡À?¨¨???LDT???¨¨¨º?¡¤?¦Ì?????¡¤?¡À¡ê¡ä??¨²¡À?¨¨???¦Ì?TSS??.¦Ì¡ÀCPU?¡äDD?D??¨¨???¨º¡À,?¨¢¡Á??¡¥¡ä¨®TSS?D¡ã?LDT???¨¨¨º?¡¤?¦Ì?????¡¤??¨®??¦Ì?ldtr??¡ä??¡Â?D.
	p->tss.back_link = 0;
	p->tss.esp0 = PAGE_SIZE + (long) p;		// ¨¨????¨²o?¨¬???????.
	p->tss.ss0 = 0x10;              		// ?¨²o?¨¬???¦Ì???????¡¤?(¨®??¨²o?¨ºy?Y???¨¤¨ª?).
	p->tss.eip = eip;						// ??¨¢?¡ä¨²??????.
	p->tss.eflags = eflags;					// ¡À¨º????¡ä??¡Â.
	p->tss.eax = 0;							// ?a¨º?¦Ì¡Àfork()¡¤¦Ì??¨º¡ÀD???3¨¬?¨¢¡¤¦Ì??0¦Ì??-¨°¨°?¨´?¨².
	p->tss.ecx = ecx;
	p->tss.edx = edx;
	p->tss.ebx = ebx;
	p->tss.esp = esp;
	p->tss.ebp = ebp;
	p->tss.esi = esi;
	p->tss.edi = edi;
	p->tss.es = es & 0xffff;				// ????¡ä??¡Â??16??¨®DD¡ì.
	p->tss.cs = cs & 0xffff;
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
	p->tss.ldt = _LDT(nr);					// ¨¨?????2?¡À¨ª?¨¨¨º?¡¤?¦Ì?????¡¤?(LDT?¨¨¨º?¡¤??¨²GET?D).
	p->tss.trace_bitmap = 0x80000000;		// (??16??¨®DD¡ì).
	// ¨¨?1?¦Ì¡À?¡ã¨¨???¨º1¨®?¨¢?D-¡ä|¨¤¨ª?¡Â,?¨ª¡À¡ê¡ä???¨¦?????.??¡À¨¤??¨¢?clts¨®?¨®¨²??3y??????¡ä??¡ÂCR0?D¦Ì?¨¨???¨°?????(TS)¡À¨º??.??¦Ì¡À¡¤¡é¨¦¨²¨¨????D??,CPU???¨¢¨¦¨¨????¡À¨º??.??¡À¨º??¨®?¨®¨²1¨¹¨¤¨ª
	// ¨ºy?¡ìD-¡ä|¨¤¨ª?¡Â:¨¨?1???¡À¨º??????,???¡ä????ESC??¨¢????¨¢¡À?2???(¨°¨¬3¡ê7).¨¨?1?D-¡ä|¨¤¨ª?¡Â¡ä??¨²¡À¨º??MP¨°2¨ª?¨º¡À????¦Ì??¡ã,???¡äWAIT??¨¢?¨°2?¨¢2???.¨°¨°¡ä?,¨¨?1?¨¨????D??¡¤¡é¨¦¨²?¨²¨°???
	// ESC??¨¢??a¨º??¡äDD??o¨®,?¨°D-¡ä|¨¤¨ª?¡Â?D¦Ì??¨²¨¨Y?¨ª?¨¦?¨¹D¨¨¨°a?¨²?¡äDDD?¦Ì?ESC??¨¢????¡ã¡À¡ê¡ä??e¨¤¡ä.2???¡ä|¨¤¨ª??¡À¨²?¨¢¡À¡ê¡ä?D-¡ä|¨¤¨ª?¡Â¦Ì??¨²¨¨Y2¡é?¡ä??TS¡À¨º??.??¨¢?fnsave¨®?¨®¨²¡ã?D-¡ä|¨¤¨ª?¡Â¦Ì?
	// ?¨´¨®D¡Á¡ä¨¬?¡À¡ê¡ä?¦Ì???¦Ì?2¨´¡Á¡Â¨ºy???¡§¦Ì??¨²¡ä???¨®¨°?D(tss.i387).
	if (last_task_used_math == current)
		__asm__("clts ; fnsave %0 ; frstor %0"::"m" (p->tss.i387));
	// ?¨®??¨¤¡ä?¡ä????3¨¬¨°3¡À¨ª.?¡ä?¨²??D?¦Ì??¡¤????¨¦¨¨??D?¨¨???¡ä¨²????o¨ª¨ºy?Y???¨¨¨º?¡¤??D¦Ì??¨´?¡¤o¨ª?T3¡è,2¡é?¡ä??¨°3¡À¨ª.¨¨?1?3?¡ä¨ª(¡¤¦Ì???¦Ì2?¨º?0),?¨°?¡ä??¨¨???¨ºy¡Á¨¦?D?¨¤¨®|??2¡é
	// ¨º¨ª¡¤??a??D?¨¨???¡¤???¦Ì?¨®?¨®¨²¨¨????¨¢11¦Ì??¨²¡ä?¨°3.
	if (copy_mem(nr, p)) {					// ¡¤¦Ì??2??a0¨º?3?¡ä¨ª.
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
	// ¨¨?1?????3¨¬?D¨®D???t¨º?¡ä¨°?a¦Ì?,?¨°????¨®|???t¦Ì?¡ä¨°?a¡ä?¨ºy??1.¨°¨°?a?a¨¤?¡ä¡ä?¡§¦Ì?¡Á¨®??3¨¬?¨¢¨®?????3¨¬12?¨ª?aD?¡ä¨°?a¦Ì????t.??¦Ì¡À?¡ã??3¨¬(????3¨¬)¦Ì?pwd,rooto¨ª
	// executable¨°y¨®?¡ä?¨ºy?¨´??1.¨®?¨¦???¨ª??¨´¦Ì?¦Ì¨¤¨¤¨ª,¡Á¨®??3¨¬¨°2¨°y¨®?¨¢??aD?i?¨²¦Ì?.
	for (i = 0; i < NR_OPEN; i++)
		if (f = p->filp[i])
			f->f_count++;
	if (current->pwd)
		current->pwd->i_count++;
	if (current->root)
		current->root->i_count++;
	if (current->executable)
		current->executable->i_count++;
	if (current->library)
		current->library->i_count++;
	// ??o¨®?¨²GDT¡À¨ª?D¨¦¨¨??D?¨¨???TSS??o¨ªLDT???¨¨¨º?¡¤???.?a¨¢?????¦Ì??T3¡è?¨´¡À?¨¦¨¨??3¨¦104¡Á??¨².2???include/asm/system.h.¨¨?o¨®¨¦¨¨????3¨¬????¦Ì?1??¦Ì¨¢¡ä¡À¨ª????,?¡ä¡ã?D???3¨¬2?¨¨?
	// ¦Ì?¦Ì¡À?¡ã??3¨¬¦Ì?¡Á¨®??3¨¬¨¢¡ä¡À¨ª?D.¡ã?D???3¨¬¦Ì?????3¨¬¨¦¨¨???a¦Ì¡À?¡ã??3¨¬,¡ã?D???3¨¬¦Ì?¡Á?D?¡Á¨®??3¨¬????p_cpto¨ª?¨º?¨¢D?¦Ì¨¹??3¨¬????p_ysptr????.?¨®¡Á?¨¨?D???3¨¬¦Ì?¨¤?D???3¨¬????p_osptr
	// ¨¦¨¨??¦Ì¨¨¨®¨²????3¨¬¦Ì?¡Á?D?¡Á¨®??3¨¬????.¨¨?¦Ì¡À?¡ã??3¨¬¨¨¡¤¨º¦Ì?1¨®D????¡Á¨®??3¨¬,?¨°¨¨?¡À¨¨¨¢¨²¨¤?D???3¨¬¦Ì?¡Á??¨º?¨¢??3¨¬????p_yspter???¨°D???3¨¬.¡Á?o¨®¡ã?¦Ì¡À?¡ã??3¨¬¦Ì?¡Á?D?¡Á¨®??3¨¬???????¨°?a??D???3¨¬.
	// ¨¨?o¨®¡ã?D???3¨¬¨¦¨¨??3¨¦?¨ªD¡Â¨¬?.¡Á?o¨®¡¤¦Ì??D???3¨¬o?.
	// ¨¢¨ª¨ªa,set_tss_desc()o¨ªset_ldt_desc()?¡§¨°??¨²include/asm/system.h???t?D."gdt+(nr<<1)+FIRST_TSS_ENTRY"¨º?¨¨???nr¦Ì?TSS?¨¨¨º?¡¤????¨²¨¨???¡À¨ª?D¦Ì?¦Ì??¡¤.
	// ¨°¨°?a????¨¨?????¨®?GDT¡À¨ª?D2??,¨°¨°¡ä?¨¦?¨º??D¨°a¡ã¨¹¨¤¡§'(nr<<1)'.
	// ??¡Á¡é¨°a,?¨²¨¨????D??¨º¡À,¨¨?????¡ä??¡Âtr?¨¢¨®¨¦CPU¡Á??¡¥?¨®??.
	set_tss_desc(gdt + (nr << 1) + FIRST_TSS_ENTRY, &(p->tss));
	set_ldt_desc(gdt + (nr << 1) + FIRST_LDT_ENTRY, &(p->ldt));
	p->p_pptr = current;				// ¨¦¨¨??D???3¨¬¦Ì?????3¨¬????.
	p->p_cptr = 0;						// ?¡ä??D???3¨¬¦Ì?¡Á?D?¡Á¨®??3¨¬????.
	p->p_ysptr = 0;						// ?¡ä??D???3¨¬¦Ì?¡À¨¨¨¢¨²?¨º?¨¢D?¦Ì¨¹??3¨¬????.
	p->p_osptr = current->p_cptr;		// ¨¦¨¨??D???3¨¬¦Ì?¡À¨¨¨¢¨²¨¤?D?D?¦Ì¨¹??3¨¬????.
	if (p->p_osptr)						// ¨¨?D???3¨¬¨®D¨¤?D?D?¦Ì¨¹??3¨¬,?¨°¨¨????¨º?¨¢??3¨¬D?¦Ì¨¹???????¨°D???3¨¬
		p->p_osptr->p_ysptr = p;
	current->p_cptr = p;				// ¨¨?¦Ì¡À?¡ã??3¨¬¡Á?D?¡Á¨®??3¨¬???????¨°D???3¨¬.
	p->state = TASK_RUNNING;			/* do this last, just in case */        /* ¨¦¨¨????3¨¬¡Á¡ä¨¬??a¡äy??DD¡Á¡ä¨¬?¨¤? */
	//Log(LOG_INFO_TYPE, "<<<<< fork new process current_pid = %d, child_pid = %d, nr = %d >>>>>\n", current->pid, p->pid, nr);
	return last_pid;        			// ¡¤¦Ì??D???3¨¬o?
}

// ?aD???3¨¬¨¨?¦Ì?2????¡ä¦Ì???3¨¬o?last_pid.o¡¥¨ºy¡¤¦Ì???¨²¨¨???¨ºy¡Á¨¦?D¦Ì?¨¨???o?(¨ºy¡Á¨¦??).
int find_empty_process(void)
{
	int i;

	// ¨º¡Á?¨¨??¨¨?D?¦Ì???3¨¬o?.¨¨?1?last_pid??1o¨®3?3???3¨¬o?¦Ì??y¨ºy¡À¨ª¨º?¡¤??¡ì,?¨°??D?¡ä¨®1?a¨º?¨º1¨®?pido?.¨¨?o¨®?¨²¨¨???¨ºy¡Á¨¦?D???¡Â??¨¦¨¨??¦Ì?pido?¨º?
	// ¡¤?¨°??-¡À?¨¨?o?¨¨???¨º1¨®?.¨¨?1?¨º??¨°¨¬?¡Áa¦Ì?o¡¥¨ºy?a¨º?¡ä|¨¤¨ª??D???¦Ì?¨°???pido?.?¨®¡Á??¨²¨¨???¨ºy¡Á¨¦?D?aD?¨¨????¡ã?¨°¨°??????D??,2¡é¡¤¦Ì????o?.last_pid¨º?¨°?
	// ??¨¨???¡À?¨¢?,2?¨®?¡¤¦Ì??.¨¨?1?¡ä?¨º¡À¨¨???¨ºy¡Á¨¦?D64????¨°??-¡À?¨¨?2???¨®?,?¨°¡¤¦Ì??3?¡ä¨ª??.
	repeat:
		if ((++last_pid) < 0) last_pid = 1;
		for(i = 0 ; i < NR_TASKS ; i++)
			if (task[i] && ((task[i]->pid == last_pid) ||
				        (task[i]->pgrp == last_pid)))
				goto repeat;
	for(i = 1 ; i < NR_TASKS ; i++)
		if (!task[i])
			return i;
	return -EAGAIN;
}


